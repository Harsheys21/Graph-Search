For this assignment, I essentially used the graphs demo for the enqueue, dequeue, and the bfs function. The enqueue function essentially checks if the node exists and if it doesn't then creates and returns it. If it does exist, a linked path is created and assigned at the bottom using a while loop. The dequeue is the same as the demo. For the bfs function, I followed the demo and created a to_visit and visited except for to_visit, it was a LLPath instead. I take my initial number, turn it into a path and put it into to_visit. After this, I start my while loop which checks if to_visit != NULL. In the while loop, I dequeue and check if the vertices is equal to j. If not equal to j, I added the vertices to the set and get the successors which are added to to_visit as paths. For dfs, it's exactly the same as bfs except for the fact that it uses a push_path function which pushes a number to the top instead to the bottom. Finally, for freeing, I first free the graph by freeing the arrays in arrays, vertices, and g itself. I also close the file in hw5.c using fileclose(). For the linked list int and path, I use the demo to create a free_ll and free_lp function which frees the linked lists recursively. Finally, I free the linked lists as I'm about return something in the bfs and the dfs. Also, dequeue automatically frees all paths that get popped so I don't have to worry about that.